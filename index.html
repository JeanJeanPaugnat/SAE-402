<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>â˜• Coffee Cup AR - SAE 402</title>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
      
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px;
        border-radius: 10px;
        z-index: 1000;
        max-width: 320px;
      }
      #info h2 { margin: 0 0 10px 0; font-size: 18px; }
      #info p { margin: 5px 0; font-size: 14px; }
      #count { color: #4CC3D9; font-weight: bold; }
      #debug { font-size: 12px; color: #FFD700; margin-top: 10px; font-family: monospace; }
      
      #start-ar-btn {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 18px 40px;
        font-size: 20px;
        font-weight: bold;
        background: linear-gradient(135deg, #4CC3D9, #3498db);
        color: white;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        z-index: 9999;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        transition: transform 0.2s, box-shadow 0.2s;
      }
      #start-ar-btn:hover {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      }
    </style>
  </head>
  <body>
    <!-- Interface HTML visible sur l'Ã©cran -->
    <div id="info">
      <h2>â˜• Coffee Cup AR</h2>
      <p>Placez des tasses de cafÃ© dans votre espace !</p>
      <p id="count">Tasses placÃ©es: 0</p>
      <p id="debug">Ã‰tat: PrÃªt</p>
    </div>

    <button id="start-ar-btn">ðŸ¥½ DÃ©marrer en AR</button>

    <!-- ScÃ¨ne A-Frame -->
    <a-scene 
      webxr="requiredFeatures: local-floor, hit-test; optionalFeatures: anchors, hand-tracking; referenceSpaceType: local-floor;"
      vr-mode-ui="enabled: false"
      renderer="colorManagement: true; physicallyCorrectLights: true; alpha: true; antialias: true"
      background="color: transparent"
      ar-coffee-placer>
      
      <!-- ============ ASSETS ============ -->
      <a-assets>
        <a-asset-item id="coffee-cup-model" src="./models/Coffee cup.glb"></a-asset-item>
        <a-asset-item id="coffee-machine-model" src="./models/Coffee Machine.glb"></a-asset-item>
      </a-assets>

      <!-- ============ Ã‰CLAIRAGE ============ -->
      <a-light type="ambient" intensity="0.7"></a-light>
      <a-light type="directional" position="1 2 1" intensity="0.9" cast-shadow="true"></a-light>

      <!-- ============ CAMÃ‰RA ============ -->
      <a-camera position="0 1.6 0">
        <!-- RÃ©ticule au centre de la vue (visible dans le casque) -->
        <a-ring id="center-reticle" 
                position="0 0 -1.5" 
                radius-inner="0.015" 
                radius-outer="0.025" 
                color="#00FF00"
                material="shader: flat; opacity: 0.8">
        </a-ring>
        
        <!-- Texte de debug visible dans le casque -->
        <a-text id="vr-debug-text" 
                value="PrÃªt" 
                position="0 0.35 -1" 
                scale="0.4 0.4 0.4" 
                color="#00FF00" 
                align="center"
                material="shader: flat">
        </a-text>
      </a-camera>
      
      <!-- ============ CURSEUR DE PLACEMENT ============ -->
      <a-entity id="placement-cursor" visible="false">
        <!-- Cercle externe -->
        <a-ring color="#00FF00" 
                radius-inner="0.08" 
                radius-outer="0.12" 
                rotation="-90 0 0"
                material="shader: flat; opacity: 0.9">
        </a-ring>
        <!-- Cercle interne -->
        <a-ring color="#FFFF00" 
                radius-inner="0.03" 
                radius-outer="0.05" 
                rotation="-90 0 0"
                material="shader: flat">
        </a-ring>
        <!-- FlÃ¨che vers le haut -->
        <a-cone color="#00FF00" 
                height="0.12" 
                radius-bottom="0.03" 
                radius-top="0" 
                position="0 0.06 0"
                material="shader: flat">
        </a-cone>
      </a-entity>

      <!-- ============ PRÃ‰VISUALISATION DE LA TASSE ============ -->
      <a-entity id="cup-preview" visible="false">
        <a-entity gltf-model="#coffee-cup-model" 
                  scale="0.1 0.1 0.1"
                  material="opacity: 0.5; transparent: true">
        </a-entity>
      </a-entity>

    </a-scene>

    <!-- ============ COMPOSANT AR COFFEE PLACER ============ -->
    <script>
      /**
       * Composant : ar-coffee-placer
       * Description : Permet de placer des tasses de cafÃ© sur les surfaces rÃ©elles
       * Utilise WebXR Hit-Test et Anchors API
       */
      AFRAME.registerComponent('ar-coffee-placer', {
        schema: {
          maxCups: { type: 'number', default: 20 },
          cupScale: { type: 'number', default: 0.1 }
        },

        init: function () {
          // Ã‰tat du composant
          this.placedCups = [];
          this.xrSession = null;
          this.xrRefSpace = null;
          this.hitTestSource = null;
          this.hitTestSourceRequested = false;
          this.lastHitPose = null;
          this.sessionInitialized = false;
          
          // Ã‰lÃ©ments DOM
          this.cursorEl = document.querySelector('#placement-cursor');
          this.previewEl = document.querySelector('#cup-preview');
          this.debugTextEl = document.querySelector('#vr-debug-text');
          this.debugHtmlEl = document.querySelector('#debug');
          this.countEl = document.querySelector('#count');
          this.startBtn = document.querySelector('#start-ar-btn');
          
          // Configurer le bouton AR
          this.setupARButton();
          
          // Ã‰couter les Ã©vÃ©nements de session
          this.el.sceneEl.addEventListener('enter-vr', this.onEnterVR.bind(this));
          this.el.sceneEl.addEventListener('exit-vr', this.onExitVR.bind(this));
          
          this.log('â˜• Coffee Placer initialisÃ©');
        },

        log: function (message) {
          console.log('[AR]', message);
          
          // Mettre Ã  jour le debug HTML
          if (this.debugHtmlEl) {
            this.debugHtmlEl.textContent = 'Ã‰tat: ' + message;
          }
          
          // Mettre Ã  jour le debug VR
          if (this.debugTextEl) {
            this.debugTextEl.setAttribute('value', message);
          }
        },

        setupARButton: function () {
          const self = this;
          
          this.startBtn.addEventListener('click', async () => {
            try {
              // VÃ©rifier si WebXR est supportÃ©
              if (!navigator.xr) {
                throw new Error('WebXR non supportÃ©');
              }
              
              // VÃ©rifier si le mode AR est supportÃ©
              const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
              if (!arSupported) {
                throw new Error('Mode AR non supportÃ©');
              }
              
              self.log('DÃ©marrage AR...');
              
              // Demander une session AR avec passthrough
              const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local-floor', 'hit-test'],
                optionalFeatures: ['anchors', 'hand-tracking', 'dom-overlay'],
                domOverlay: { root: document.querySelector('#info') }
              });
              
              // IMPORTANT: Configurer le renderer pour le passthrough
              const renderer = self.el.sceneEl.renderer;
              renderer.xr.setSession(session);
              
              // S'assurer que le background est transparent pour le passthrough
              const scene = self.el.sceneEl.object3D;
              if (scene && scene.background) {
                scene.background = null;
              }
              
              // Cacher le bouton
              self.startBtn.style.display = 'none';
              
              self.log('Session AR OK !');
              
              // IMPORTANT: Initialiser directement (ne pas attendre enter-vr)
              setTimeout(() => {
                self.initializeSession();
              }, 800);
              
            } catch (error) {
              self.log('Erreur: ' + error.message);
              console.error('AR Error:', error);
              alert('Erreur AR: ' + error.message);
            }
          });
        },

        onEnterVR: async function () {
          this.log('EntrÃ©e VR/AR');
          
          // Attendre que la session soit Ã©tablie (augmentÃ© pour plus de stabilitÃ©)
          setTimeout(() => {
            this.initializeSession();
          }, 800);
        },

        onExitVR: function () {
          this.log('Sortie VR/AR');
          
          // Nettoyer proprement
          if (this.hitTestSource) {
            try {
              this.hitTestSource.cancel();
            } catch (e) {
              console.warn('Hit-test cancel error:', e);
            }
            this.hitTestSource = null;
          }
          this.hitTestSourceRequested = false;
          this.sessionInitialized = false;
          
          // RÃ©afficher le bouton
          this.startBtn.style.display = 'block';
        },

        initializeSession: async function () {
          this.xrSession = this.el.sceneEl.renderer.xr.getSession();
          this.xrRefSpace = this.el.sceneEl.renderer.xr.getReferenceSpace();
          
          if (!this.xrSession) {
            this.log('Pas de session XR');
            return;
          }
          
          this.sessionInitialized = true;
          this.log('Session OK');
          
          // VÃ©rifier les features disponibles
          if (this.xrSession.enabledFeatures) {
            console.log('Features activÃ©es:', this.xrSession.enabledFeatures);
            this.log('Features: ' + this.xrSession.enabledFeatures.join(', '));
          }
          
          // IMPORTANT: CrÃ©er un hit-test source "viewer" comme fallback
          // Cela fonctionne avec le regard (pas besoin de manette)
          try {
            const viewerSpace = await this.xrSession.requestReferenceSpace('viewer');
            this.hitTestSource = await this.xrSession.requestHitTestSource({ space: viewerSpace });
            this.hitTestSourceRequested = true;
            this.log('Hit-test (viewer) OK !');
          } catch (error) {
            this.log('Hit-test error: ' + error.message);
          }
          
          // Ã‰couter les Ã©vÃ©nements "select" (trigger de la manette ou tap)
          this.xrSession.addEventListener('select', this.onSelect.bind(this));
          
          // Log des input sources
          const inputSources = this.xrSession.inputSources;
          this.log(`Inputs: ${inputSources.length} dÃ©tectÃ©s`);
          
          this.log('PrÃªt ! Visez et appuyez');
        },

        onSelect: function (event) {
          this.log('>>> TRIGGER ! <<<');
          
          if (!this.lastHitPose) {
            this.log('Aucune surface dÃ©tectÃ©e');
            return;
          }
          
          // Placer une tasse Ã  la position dÃ©tectÃ©e
          this.placeCup(this.lastHitPose);
        },

        placeCup: function (pose) {
          const position = pose.position;
          const orientation = pose.orientation;
          
          // CrÃ©er l'entitÃ© tasse
          const cupEntity = document.createElement('a-entity');
          cupEntity.setAttribute('gltf-model', '#coffee-cup-model');
          cupEntity.setAttribute('scale', `${this.data.cupScale} ${this.data.cupScale} ${this.data.cupScale}`);
          cupEntity.setAttribute('position', {
            x: position.x,
            y: position.y,
            z: position.z
          });
          
          // Animation d'apparition
          cupEntity.setAttribute('animation', {
            property: 'scale',
            from: '0 0 0',
            to: `${this.data.cupScale} ${this.data.cupScale} ${this.data.cupScale}`,
            dur: 400,
            easing: 'easeOutBack'
          });
          
          // Ajouter Ã  la scÃ¨ne
          this.el.sceneEl.appendChild(cupEntity);
          this.placedCups.push(cupEntity);
          
          // Limiter le nombre de tasses
          if (this.placedCups.length > this.data.maxCups) {
            const oldCup = this.placedCups.shift();
            if (oldCup.parentNode) {
              oldCup.parentNode.removeChild(oldCup);
            }
          }
          
          // Mettre Ã  jour le compteur
          this.updateCount();
          
          this.log(`Tasse placÃ©e ! (${this.placedCups.length})`);
        },

        updateCount: function () {
          if (this.countEl) {
            this.countEl.textContent = `Tasses placÃ©es: ${this.placedCups.length}`;
          }
        },

        tick: function (time, delta) {
          if (!this.sessionInitialized || !this.xrSession || !this.xrRefSpace) {
            return;
          }
          
          const frame = this.el.sceneEl.frame;
          if (!frame) return;
          
          // Effectuer le hit-test (utilise le viewer/regard)
          if (this.hitTestSource) {
            try {
              const hitTestResults = frame.getHitTestResults(this.hitTestSource);
              
              if (hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                const hitPose = hit.getPose(this.xrRefSpace);
                
                if (hitPose) {
                  // Surface dÃ©tectÃ©e !
                  this.lastHitPose = hitPose.transform;
                  this.updateCursor(hitPose.transform, true);
                  
                  // Debug occasionnel (toutes les 60 frames)
                  this.hitCount = (this.hitCount || 0) + 1;
                  if (this.hitCount % 60 === 1) {
                    const pos = hitPose.transform.position;
                    this.log(`Surface: ${pos.y.toFixed(2)}m`);
                  }
                }
              } else {
                // Pas de surface dÃ©tectÃ©e
                this.updateCursor(null, false);
                
                // Debug occasionnel
                this.noHitCount = (this.noHitCount || 0) + 1;
                if (this.noHitCount % 120 === 1) {
                  this.log('Cherche surface...');
                }
              }
            } catch (error) {
              // Erreur silencieuse
              console.warn('Hit-test error:', error);
            }
          } else {
            // Pas encore de hit-test source
            this.waitCount = (this.waitCount || 0) + 1;
            if (this.waitCount % 120 === 1) {
              this.log('Attente hit-test...');
            }
          }
        },

        updateCursor: function (pose, detected) {
          if (!this.cursorEl) return;
          
          if (detected && pose) {
            // Afficher le curseur Ã  la position dÃ©tectÃ©e
            this.cursorEl.object3D.visible = true;
            this.cursorEl.object3D.position.set(
              pose.position.x,
              pose.position.y,
              pose.position.z
            );
            this.cursorEl.object3D.quaternion.set(
              pose.orientation.x,
              pose.orientation.y,
              pose.orientation.z,
              pose.orientation.w
            );
            
            // Couleur verte = surface dÃ©tectÃ©e
            this.cursorEl.querySelectorAll('a-ring').forEach(ring => {
              ring.setAttribute('color', '#00FF00');
            });
            
            // Afficher la prÃ©visualisation de la tasse
            if (this.previewEl) {
              this.previewEl.object3D.visible = true;
              this.previewEl.object3D.position.set(
                pose.position.x,
                pose.position.y,
                pose.position.z
              );
            }
          } else {
            // Cacher le curseur
            this.cursorEl.object3D.visible = false;
            if (this.previewEl) {
              this.previewEl.object3D.visible = false;
            }
            this.lastHitPose = null;
          }
        },

        remove: function () {
          // Nettoyer les tasses
          this.placedCups.forEach(cup => {
            if (cup.parentNode) {
              cup.parentNode.removeChild(cup);
            }
          });
          this.placedCups = [];
        }
      });
    </script>
  </body>
</html>
