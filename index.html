<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>‚òï Coffee Cup AR - Simplifi√©</title>
  <link rel="stylesheet" href="src/style.css">
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <!-- Physics system avec CANNON.js -->
  <script
    src="https://cdn.jsdelivr.net/gh/c-frame/aframe-physics-system@v4.2.2/dist/aframe-physics-system.min.js"></script>

</head>

<body>
  <!-- Interface HTML -->
  <div id="info">
    <h2>‚òï Coffee Cup AR</h2>
    <p><strong>Bouton A</strong> = Spawn tasse en main</p>
    <p><strong>Trigger</strong> = L√¢cher la tasse</p>
    <hr>
    <p id="count">Tasses: 0</p>
    <p id="planes-count">Plans d√©tect√©s: 0</p>
    <p id="debug">√âtat: Pr√™t</p>
  </div>

  <button id="start-ar-btn">ü•Ω D√©marrer en AR</button>

  <!-- Sc√®ne A-Frame -->
  <a-scene
    webxr="requiredFeatures: local-floor; optionalFeatures: plane-detection, anchors; referenceSpaceType: local-floor;"
    vr-mode-ui="enabled: false" renderer="colorManagement: true; alpha: true; antialias: true"
    background="color: transparent" physics="driver: local; gravity: -9.8; debug: false" ar-session-manager
    ar-plane-detector="showPlanes: true">

    <!-- ============ ASSETS ============ -->
    <a-assets>
      <a-asset-item id="coffee-cup-model" src="./public/models/Coffee cup.glb"></a-asset-item>
    </a-assets>

    <!-- ============ √âCLAIRAGE ============ -->
    <a-light type="ambient" intensity="0.8"></a-light>
    <a-light type="directional" position="1 2 1" intensity="0.7"></a-light>

    <!-- ============ CAM√âRA ============ -->
    <a-camera position="0 1.6 0">
      <!-- Texte de debug visible dans le casque -->
      <a-text id="vr-debug-text" value="Pr√™t" position="0 0.35 -1" scale="0.4 0.4 0.4" color="#00FF00" align="center"
        material="shader: flat">
      </a-text>
    </a-camera>

    <!-- ============ MANETTES ============ -->
    <a-entity id="left-controller" oculus-touch-controls="hand: left">
    </a-entity>

    <a-entity id="right-controller" oculus-touch-controls="hand: right" cup-spawner>
    </a-entity>

  </a-scene>

  <script>
    /**
     * =================================================================
     * Composant : ar-session-manager
     * Description : G√®re le d√©marrage de la session AR
     * =================================================================
     */
    AFRAME.registerComponent('ar-session-manager', {
      init: function () {
        this.startBtn = document.querySelector('#start-ar-btn');
        this.debugEl = document.querySelector('#debug');
        this.debugVREl = document.querySelector('#vr-debug-text');
        this.sessionActive = false;

        this.setupButton();

        this.el.sceneEl.addEventListener('enter-vr', () => {
          this.sessionActive = true;
          this.log('Session AR active');
          this.startBtn.style.display = 'none';
        });

        this.el.sceneEl.addEventListener('exit-vr', () => {
          this.sessionActive = false;
          this.log('Session AR termin√©e');
          this.startBtn.style.display = 'block';
        });
      },

      log: function (msg) {
        console.log('[AR]', msg);
        if (this.debugEl) this.debugEl.textContent = '√âtat: ' + msg;
        if (this.debugVREl) this.debugVREl.setAttribute('value', msg);
      },

      setupButton: function () {
        const self = this;

        this.startBtn.addEventListener('click', async () => {
          try {
            if (!navigator.xr) throw new Error('WebXR non support√©');

            const supported = await navigator.xr.isSessionSupported('immersive-ar');
            if (!supported) throw new Error('AR non support√©');

            self.log('D√©marrage AR...');

            const session = await navigator.xr.requestSession('immersive-ar', {
              requiredFeatures: ['local-floor'],
              optionalFeatures: ['plane-detection', 'anchors', 'dom-overlay'],
              domOverlay: { root: document.querySelector('#info') }
            });

            self.el.sceneEl.renderer.xr.setSession(session);
            self.startBtn.style.display = 'none';

          } catch (err) {
            self.log('Erreur: ' + err.message);
            alert('Erreur: ' + err.message);
          }
        });
      }
    });

    /**
     * =================================================================
     * Composant : cup-spawner
     * Description : Spawn une tasse avec Bouton A, la l√¢che avec Trigger
     * =================================================================
     */
    AFRAME.registerComponent('cup-spawner', {
      schema: {
        cupScale: { type: 'number', default: 0.1 }
      },

      init: function () {
        this.heldCup = null;
        this.cupCount = 0;
        this.allCups = [];

        // √âcouter les boutons
        this.el.addEventListener('abuttondown', this.onAButton.bind(this));
        this.el.addEventListener('triggerdown', this.onTrigger.bind(this));

        console.log('‚òï Cup-spawner initialis√©');
      },

      onAButton: function () {
        if (this.heldCup) {
          this.log('D√©j√† une tasse en main !');
          return;
        }
        this.spawnCupInHand();
      },

      spawnCupInHand: function () {
        const cup = document.createElement('a-entity');
        cup.setAttribute('gltf-model', '#coffee-cup-model');
        cup.setAttribute('scale', `${this.data.cupScale} ${this.data.cupScale} ${this.data.cupScale}`);
        cup.setAttribute('id', `cup-${Date.now()}`);
        cup.setAttribute('position', '0 0.05 -0.05');

        // Attacher √† la manette
        this.el.appendChild(cup);
        this.heldCup = cup;
        this.cupCount++;

        // Animation d'apparition
        cup.addEventListener('model-loaded', () => {
          cup.setAttribute('animation', {
            property: 'scale',
            from: '0 0 0',
            to: `${this.data.cupScale} ${this.data.cupScale} ${this.data.cupScale}`,
            dur: 300,
            easing: 'easeOutBack'
          });
        });

        this.log('Tasse en main ! Trigger = l√¢cher');
        this.updateCount();
      },

      onTrigger: function () {
        if (!this.heldCup) return;
        this.releaseCup();
      },

      releaseCup: function () {
        if (!this.heldCup) return;

        // R√©cup√©rer position/rotation mondiale
        const worldPos = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        this.heldCup.object3D.getWorldPosition(worldPos);
        this.heldCup.object3D.getWorldQuaternion(worldQuat);

        // D√©tacher de la manette
        const cup = this.heldCup;
        this.el.removeChild(cup);

        // Ajouter √† la sc√®ne
        this.el.sceneEl.appendChild(cup);

        // Positionner dans le monde
        cup.object3D.position.copy(worldPos);
        cup.object3D.quaternion.copy(worldQuat);

        // Ajouter la physique apr√®s un court d√©lai
        setTimeout(() => {
          cup.setAttribute('dynamic-body', {
            mass: 0.3,
            shape: 'box',
            linearDamping: 0.3,
            angularDamping: 0.5
          });

          this.log('Tasse l√¢ch√©e !');
        }, 50);

        this.allCups.push(cup);
        this.heldCup = null;
      },

      log: function (msg) {
        console.log('‚òï', msg);
        const debugEl = document.querySelector('#debug');
        const debugVR = document.querySelector('#vr-debug-text');
        if (debugEl) debugEl.textContent = '√âtat: ' + msg;
        if (debugVR) debugVR.setAttribute('value', msg);
      },

      updateCount: function () {
        const countEl = document.querySelector('#count');
        if (countEl) countEl.textContent = `Tasses: ${this.cupCount}`;
      }
    });

    /**
     * =================================================================
     * Composant : ar-plane-detector
     * Description : D√©tecte les plans et cr√©e des colliders physiques
     * =================================================================
     */
    AFRAME.registerComponent('ar-plane-detector', {
      schema: {
        showPlanes: { type: 'boolean', default: true },
        horizontalColor: { type: 'color', default: '#00FF00' },
        verticalColor: { type: 'color', default: '#0088FF' }
      },

      init: function () {
        this.detectedPlanes = new Map();
        this.xrSession = null;
        this.xrRefSpace = null;
        this.initialized = false;
        this.frameCount = 0;

        this.el.sceneEl.addEventListener('enter-vr', () => {
          setTimeout(() => this.initSession(), 1000);
        });

        this.el.sceneEl.addEventListener('exit-vr', () => {
          this.cleanup();
        });

        console.log('[Planes] Composant initialis√©');
      },

      initSession: function () {
        this.xrSession = this.el.sceneEl.renderer.xr.getSession();
        this.xrRefSpace = this.el.sceneEl.renderer.xr.getReferenceSpace();

        if (this.xrSession) {
          this.initialized = true;
          console.log('[Planes] Session OK');

          if (this.xrSession.enabledFeatures) {
            const hasPlanes = this.xrSession.enabledFeatures.includes('plane-detection');
            console.log('[Planes] plane-detection:', hasPlanes);
          }
        }
      },

      tick: function () {
        if (!this.initialized || !this.xrSession || !this.xrRefSpace) return;

        const frame = this.el.sceneEl.frame;
        if (!frame || !frame.detectedPlanes) return;

        this.frameCount++;

        // Mettre √† jour le compteur de plans
        if (this.frameCount % 30 === 0) {
          this.updatePlanesCount(frame.detectedPlanes.size);
        }

        // Cr√©er/mettre √† jour les plans
        frame.detectedPlanes.forEach((plane) => {
          if (!this.detectedPlanes.has(plane)) {
            this.createPlane(plane, frame);
          } else {
            this.updatePlane(plane, frame);
          }
        });

        // Supprimer les plans obsol√®tes
        this.detectedPlanes.forEach((entity, plane) => {
          if (!frame.detectedPlanes.has(plane)) {
            this.removePlane(plane);
          }
        });
      },

      createPlane: function (plane, frame) {
        try {
          const pose = frame.getPose(plane.planeSpace, this.xrRefSpace);
          if (!pose) return;

          const pos = pose.transform.position;
          const ori = pose.transform.orientation;
          const dims = this.getDimensions(plane.polygon);

          // Cr√©er l'entit√©
          const entity = document.createElement('a-box');
          entity.setAttribute('position', { x: pos.x, y: pos.y, z: pos.z });
          entity.object3D.quaternion.set(ori.x, ori.y, ori.z, ori.w);

          // Dimensions selon orientation
          const isHorizontal = plane.orientation === 'horizontal';
          entity.setAttribute('scale', {
            x: dims.width,
            y: isHorizontal ? 0.02 : dims.height,
            z: isHorizontal ? dims.height : 0.02
          });

          // Apparence (debug)
          if (this.data.showPlanes) {
            entity.setAttribute('material', {
              color: isHorizontal ? this.data.horizontalColor : this.data.verticalColor,
              opacity: 0.3,
              transparent: true,
              shader: 'flat'
            });
          } else {
            entity.setAttribute('visible', false);
          }

          // ‚ö° PHYSIQUE : Collider statique
          entity.setAttribute('static-body', '');

          entity.classList.add('plane', isHorizontal ? 'horizontal' : 'vertical');

          this.el.sceneEl.appendChild(entity);
          this.detectedPlanes.set(plane, entity);

          console.log(`[Planes] Nouveau plan ${plane.orientation}: ${dims.width.toFixed(2)}x${dims.height.toFixed(2)}m`);

        } catch (e) {
          console.warn('[Planes] Erreur cr√©ation:', e);
        }
      },

      updatePlane: function (plane, frame) {
        const entity = this.detectedPlanes.get(plane);
        if (!entity) return;

        try {
          const pose = frame.getPose(plane.planeSpace, this.xrRefSpace);
          if (!pose) return;

          const pos = pose.transform.position;
          const ori = pose.transform.orientation;

          entity.object3D.position.set(pos.x, pos.y, pos.z);
          entity.object3D.quaternion.set(ori.x, ori.y, ori.z, ori.w);

        } catch (e) { }
      },

      removePlane: function (plane) {
        const entity = this.detectedPlanes.get(plane);
        if (entity && entity.parentNode) {
          entity.parentNode.removeChild(entity);
        }
        this.detectedPlanes.delete(plane);
        console.log('[Planes] Plan supprim√©');
      },

      getDimensions: function (polygon) {
        if (!polygon || polygon.length < 3) {
          return { width: 0.5, height: 0.5 };
        }

        let minX = Infinity, maxX = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;

        for (const p of polygon) {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minZ = Math.min(minZ, p.z);
          maxZ = Math.max(maxZ, p.z);
        }

        return {
          width: Math.max(maxX - minX, 0.1),
          height: Math.max(maxZ - minZ, 0.1)
        };
      },

      updatePlanesCount: function (count) {
        const el = document.querySelector('#planes-count');
        if (el) el.textContent = `Plans d√©tect√©s: ${count}`;
      },

      cleanup: function () {
        this.detectedPlanes.forEach((entity) => {
          if (entity.parentNode) entity.parentNode.removeChild(entity);
        });
        this.detectedPlanes.clear();
        this.initialized = false;
        console.log('[Planes] Nettoy√©');
      }
    });
  </script>
</body>

</html>