<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>‚òï Coffee Cup AR - SAE 402</title>
  <link rel="stylesheet" href="src/style.css">
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <!-- Physics system avec CANNON.js -->
  <script
    src="https://cdn.jsdelivr.net/gh/c-frame/aframe-physics-system@v4.2.2/dist/aframe-physics-system.min.js"></script>
  <!-- Composants hand-grab pour saisir les objets -->
  <script src="./src/components/hand-grab.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px;
      border-radius: 10px;
      z-index: 1000;
      max-width: 320px;
    }

    #info h2 {
      margin: 0 0 10px 0;
      font-size: 18px;
    }

    #info p {
      margin: 5px 0;
      font-size: 14px;
    }

    #count {
      color: #4CC3D9;
      font-weight: bold;
    }

    #debug {
      font-size: 12px;
      color: #FFD700;
      margin-top: 10px;
      font-family: monospace;
    }

    #start-ar-btn {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      padding: 18px 40px;
      font-size: 20px;
      font-weight: bold;
      background: linear-gradient(135deg, #4CC3D9, #3498db);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      z-index: 9999;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    #start-ar-btn:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
    }
  </style>
</head>

<body>
  <!-- Interface HTML visible sur l'√©cran -->
  <div id="info">
    <h2>‚òï Coffee Cup AR</h2>
    <p>Placez des tasses de caf√© dans votre espace !</p>
    <p id="count">Tasses plac√©es: 0</p>
    <p id="debug">√âtat: Pr√™t</p>
  </div>

  <button id="start-ar-btn">ü•Ω D√©marrer en AR</button>

  <!-- Sc√®ne A-Frame -->
  <a-scene
    webxr="requiredFeatures: local-floor, hit-test; optionalFeatures: anchors, hand-tracking, plane-detection, mesh-detection; referenceSpaceType: local-floor;"
    vr-mode-ui="enabled: false"
    renderer="colorManagement: true; physicallyCorrectLights: true; alpha: true; antialias: true"
    background="color: transparent" physics="driver: local; gravity: -9.8; debug: false" ar-coffee-placer
    ar-plane-detector="showPlanes: true">

    <!-- ============ ASSETS ============ -->
    <a-assets>
      <a-asset-item id="coffee-cup-model" src="./models/Coffee cup.glb"></a-asset-item>
      <a-asset-item id="coffee-machine-model" src="./models/Coffee Machine.glb"></a-asset-item>
    </a-assets>

    <!-- ============ √âCLAIRAGE ============ -->
    <a-light type="ambient" intensity="0.7"></a-light>
    <a-light type="directional" position="1 2 1" intensity="0.9" cast-shadow="true"></a-light>

    <!-- ============ CAM√âRA ============ -->
    <a-camera position="0 1.6 0">
      <!-- R√©ticule au centre de la vue (visible dans le casque) -->
      <a-ring id="center-reticle" position="0 0 -1.5" radius-inner="0.015" radius-outer="0.025" color="#00FF00"
        material="shader: flat; opacity: 0.8">
      </a-ring>

      <!-- Texte de debug visible dans le casque -->
      <a-text id="vr-debug-text" value="Pr√™t" position="0 0.35 -1" scale="0.4 0.4 0.4" color="#00FF00" align="center"
        material="shader: flat">
      </a-text>
    </a-camera>

    <!-- ============ MAINS POUR HAND TRACKING ============ -->
    <!-- Main gauche -->
    <a-entity id="left-hand" hand-tracking-controls="hand: left; modelStyle: mesh; modelColor: #4CC3D9"
      hand-grab="hand: left">
      <!-- Sph√®re de visualisation de la zone de grab -->
      <a-sphere radius="0.02" color="#4CC3D9" material="opacity: 0.3; transparent: true"></a-sphere>
    </a-entity>

    <!-- Main droite -->
    <a-entity id="right-hand" hand-tracking-controls="hand: right; modelStyle: mesh; modelColor: #4CC3D9"
      hand-grab="hand: right">
      <!-- Sph√®re de visualisation de la zone de grab -->
      <a-sphere radius="0.02" color="#4CC3D9" material="opacity: 0.3; transparent: true"></a-sphere>
    </a-entity>

    <!-- ============ MANETTES (fallback) ============ -->
    <a-entity id="left-controller" oculus-touch-controls="hand: left" controller-grab="hand: left">
    </a-entity>

    <a-entity id="right-controller" oculus-touch-controls="hand: right" controller-grab="hand: right" cup-spawner>
    </a-entity>

    <!-- ============ CURSEUR DE PLACEMENT ============ -->
    <a-entity id="placement-cursor" visible="false">
      <!-- Cercle externe -->
      <a-ring color="#00FF00" radius-inner="0.08" radius-outer="0.12" rotation="-90 0 0"
        material="shader: flat; opacity: 0.9">
      </a-ring>
      <!-- Cercle interne -->
      <a-ring color="#FFFF00" radius-inner="0.03" radius-outer="0.05" rotation="-90 0 0" material="shader: flat">
      </a-ring>
      <!-- Fl√®che vers le haut -->
      <a-cone color="#00FF00" height="0.12" radius-bottom="0.03" radius-top="0" position="0 0.06 0"
        material="shader: flat">
      </a-cone>
    </a-entity>

    <!-- ============ SOL INVISIBLE POUR PHYSIQUE ============ -->
    <!-- Ce plan sera repositionn√© dynamiquement √† la hauteur du sol d√©tect√© -->
    <a-plane id="physics-floor" position="0 0 0" rotation="-90 0 0" width="50" height="50" visible="false" static-body>
    </a-plane>
    </a-entity>

    <!-- ============ PR√âVISUALISATION DE LA TASSE ============ -->
    <a-entity id="cup-preview" visible="false">
      <a-entity gltf-model="#coffee-cup-model" scale="0.1 0.1 0.1" material="opacity: 0.5; transparent: true">
      </a-entity>
    </a-entity>

  </a-scene>

  <!-- ============ COMPOSANT CUP SPAWNER ============ -->
  <script>
    /**
     * Composant : cup-spawner
     * Description : Permet de spawner une tasse dans la main avec le bouton A
     *               et de la poser avec le trigger
     * 
     * Workflow:
     * 1. Bouton A ‚Üí spawn une tasse attach√©e √† la manette
     * 2. Trigger ‚Üí d√©tache la tasse et la pose au sol (hit-test)
     * 3. Grip ‚Üí grab une tasse d√©j√† pos√©e
     */
    AFRAME.registerComponent('cup-spawner', {
      schema: {
        cupScale: { type: 'number', default: 0.1 },
        cupYOffset: { type: 'number', default: 0.05 }
      },

      init: function () {
        this.heldCup = null;  // La tasse actuellement en main
        this.cupCount = 0;

        // √âcouter le bouton A (abuttondown sur Oculus Touch)
        this.el.addEventListener('abuttondown', this.onAButton.bind(this));

        // √âcouter le trigger pour poser la tasse
        this.el.addEventListener('triggerdown', this.onTrigger.bind(this));

        // Obtenir la r√©f√©rence au ar-coffee-placer pour utiliser son hit-test
        this.coffePlacer = null;
        this.el.sceneEl.addEventListener('loaded', () => {
          this.coffeePlacer = document.querySelector('[ar-coffee-placer]');
          if (this.coffeePlacer) {
            this.coffeePlacer = this.coffeePlacer.components['ar-coffee-placer'];
          }
        });

        console.log('‚òï Cup-spawner initialis√©');
      },

      onAButton: function (evt) {
        // Si on a d√©j√† une tasse en main, ne rien faire
        if (this.heldCup) {
          console.log('‚òï D√©j√† une tasse en main !');
          return;
        }

        // Cr√©er une nouvelle tasse attach√©e √† la manette
        this.spawnCupInHand();
      },

      spawnCupInHand: function () {
        const cupEntity = document.createElement('a-entity');
        cupEntity.setAttribute('gltf-model', '#coffee-cup-model');
        cupEntity.setAttribute('scale', `${this.data.cupScale} ${this.data.cupScale} ${this.data.cupScale}`);
        cupEntity.setAttribute('id', `held-cup-${Date.now()}`);

        // Position relative √† la manette (l√©g√®rement devant et en haut)
        cupEntity.setAttribute('position', '0 0.05 -0.05');

        // Ajouter comme enfant de la manette (suit automatiquement)
        this.el.appendChild(cupEntity);

        this.heldCup = cupEntity;
        this.cupCount++;

        // Effet visuel (couleur l√©g√®rement diff√©rente pour montrer qu'on la tient)
        cupEntity.addEventListener('model-loaded', () => {
          cupEntity.setAttribute('animation', {
            property: 'scale',
            from: '0 0 0',
            to: `${this.data.cupScale} ${this.data.cupScale} ${this.data.cupScale}`,
            dur: 300,
            easing: 'easeOutBack'
          });
        });

        console.log(`‚òï Tasse spawned en main ! (total: ${this.cupCount})`);

        // Mettre √† jour le debug
        if (this.coffeePlacer) {
          this.coffeePlacer.log('Tasse en main - Trigger pour poser');
        }
      },

      onTrigger: function (evt) {
        // Si pas de tasse en main, ne rien faire (laisse le grab fonctionner)
        if (!this.heldCup) {
          return;
        }

        // D√©tacher et poser la tasse
        this.placeCupFromHand();
      },

      placeCupFromHand: function () {
        if (!this.heldCup) return;

        // Obtenir la position mondiale actuelle de la tasse
        const worldPos = new THREE.Vector3();
        this.heldCup.object3D.getWorldPosition(worldPos);

        const worldQuat = new THREE.Quaternion();
        this.heldCup.object3D.getWorldQuaternion(worldQuat);

        // D√©tacher de la manette
        const cupEl = this.heldCup;
        this.el.removeChild(cupEl);

        // Ajouter √† la sc√®ne principale
        this.el.sceneEl.appendChild(cupEl);

        // Positionner √† la position mondiale
        cupEl.object3D.position.copy(worldPos);
        cupEl.object3D.quaternion.copy(worldQuat);

        // Ajouter grabbable et physique
        cupEl.setAttribute('grabbable', '');

        // Ajouter la physique apr√®s le positionnement
        setTimeout(() => {
          cupEl.setAttribute('dynamic-body', {
            mass: 0.3,
            shape: 'box',
            linearDamping: 0.3,
            angularDamping: 0.3
          });

          cupEl.setAttribute('physics-material', {
            restitution: 0.4,
            friction: 0.5
          });

          // Figer temporairement pour pas qu'elle tombe imm√©diatement
          setTimeout(() => {
            if (cupEl.body) {
              cupEl.body.velocity.set(0, 0, 0);
              cupEl.body.angularVelocity.set(0, 0, 0);

              // V√©rifier si on est au-dessus d'une surface (hit-test)
              // Si oui, figer. Sinon, laisser tomber.
              if (this.coffeePlacer && this.coffeePlacer.lastHitPose) {
                const hitY = this.coffeePlacer.lastHitPose.position.y;
                // Si la tasse est proche du sol d√©tect√©, la poser
                if (Math.abs(worldPos.y - hitY) < 0.3) {
                  cupEl.body.sleep();
                  console.log('‚òï Tasse pos√©e sur surface');
                } else {
                  console.log('‚òï Tasse l√¢ch√©e en l\'air - elle tombe !');
                }
              }
            }
          }, 100);
        }, 50);

        this.heldCup = null;

        // Mettre √† jour le compteur
        if (this.coffeePlacer) {
          this.coffeePlacer.placedCups.push(cupEl);
          this.coffeePlacer.updateCount();
          this.coffeePlacer.log('Tasse pos√©e ! Bouton A = nouvelle');
        }

        console.log('‚òï Tasse pos√©e depuis la main');
      },

      tick: function () {
        // Rien √† faire - la tasse suit automatiquement car enfant de la manette
      }
    });
  </script>

  <!-- ============ COMPOSANT AR COFFEE PLACER ============ -->
  <script>
    /**
     * Composant : ar-coffee-placer
     * Description : Permet de placer des tasses de caf√© sur les surfaces r√©elles
     * Utilise WebXR Hit-Test et Anchors API
     */
    AFRAME.registerComponent('ar-coffee-placer', {
      schema: {
        maxCups: { type: 'number', default: 20 },
        cupScale: { type: 'number', default: 0.1 },
        // D√©calage vertical pour placer la tasse sur sa base (pas son centre)
        // Si le mod√®le a son origine au centre et fait ~10cm de haut avec scale 0.1
        // alors on doit d√©caler de la moiti√© de sa hauteur r√©elle
        cupYOffset: { type: 'number', default: 0.05 }  // 5cm de d√©calage par d√©faut
      },

      init: function () {
        // √âtat du composant
        this.placedCups = [];
        this.xrSession = null;
        this.xrRefSpace = null;
        this.hitTestSource = null;
        this.hitTestSourceRequested = false;
        this.lastHitPose = null;
        this.sessionInitialized = false;

        // √âl√©ments DOM
        this.cursorEl = document.querySelector('#placement-cursor');
        this.previewEl = document.querySelector('#cup-preview');
        this.debugTextEl = document.querySelector('#vr-debug-text');
        this.debugHtmlEl = document.querySelector('#debug');
        this.countEl = document.querySelector('#count');
        this.startBtn = document.querySelector('#start-ar-btn');

        // Configurer le bouton AR
        this.setupARButton();

        // √âcouter les √©v√©nements de session
        this.el.sceneEl.addEventListener('enter-vr', this.onEnterVR.bind(this));
        this.el.sceneEl.addEventListener('exit-vr', this.onExitVR.bind(this));

        this.log('‚òï Coffee Placer initialis√©');
      },

      log: function (message) {
        console.log('[AR]', message);

        // Mettre √† jour le debug HTML
        if (this.debugHtmlEl) {
          this.debugHtmlEl.textContent = '√âtat: ' + message;
        }

        // Mettre √† jour le debug VR
        if (this.debugTextEl) {
          this.debugTextEl.setAttribute('value', message);
        }
      },

      setupARButton: function () {
        const self = this;

        this.startBtn.addEventListener('click', async () => {
          try {
            // V√©rifier si WebXR est support√©
            if (!navigator.xr) {
              throw new Error('WebXR non support√©');
            }

            // V√©rifier si le mode AR est support√©
            const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
            if (!arSupported) {
              throw new Error('Mode AR non support√©');
            }

            self.log('D√©marrage AR...');

            // Demander une session AR avec passthrough et plane-detection
            const session = await navigator.xr.requestSession('immersive-ar', {
              requiredFeatures: ['local-floor', 'hit-test'],
              optionalFeatures: ['anchors', 'hand-tracking', 'plane-detection', 'mesh-detection', 'dom-overlay'],
              domOverlay: { root: document.querySelector('#info') }
            });

            // IMPORTANT: Configurer le renderer pour le passthrough
            const renderer = self.el.sceneEl.renderer;
            renderer.xr.setSession(session);

            // S'assurer que le background est transparent pour le passthrough
            const scene = self.el.sceneEl.object3D;
            if (scene && scene.background) {
              scene.background = null;
            }

            // Cacher le bouton
            self.startBtn.style.display = 'none';

            self.log('Session AR OK !');

            // IMPORTANT: Initialiser directement (ne pas attendre enter-vr)
            setTimeout(() => {
              self.initializeSession();
            }, 800);

          } catch (error) {
            self.log('Erreur: ' + error.message);
            console.error('AR Error:', error);
            alert('Erreur AR: ' + error.message);
          }
        });
      },

      onEnterVR: async function () {
        this.log('Entr√©e VR/AR');

        // Attendre que la session soit √©tablie (augment√© pour plus de stabilit√©)
        setTimeout(() => {
          this.initializeSession();
        }, 800);
      },

      onExitVR: function () {
        this.log('Sortie VR/AR');

        // Nettoyer proprement
        if (this.hitTestSource) {
          try {
            this.hitTestSource.cancel();
          } catch (e) {
            console.warn('Hit-test cancel error:', e);
          }
          this.hitTestSource = null;
        }
        this.hitTestSourceRequested = false;
        this.sessionInitialized = false;

        // R√©afficher le bouton
        this.startBtn.style.display = 'block';
      },

      initializeSession: async function () {
        this.xrSession = this.el.sceneEl.renderer.xr.getSession();
        this.xrRefSpace = this.el.sceneEl.renderer.xr.getReferenceSpace();

        if (!this.xrSession) {
          this.log('Pas de session XR');
          return;
        }

        this.sessionInitialized = true;
        this.log('Session OK');

        // V√©rifier les features disponibles
        if (this.xrSession.enabledFeatures) {
          console.log('Features activ√©es:', this.xrSession.enabledFeatures);
          this.log('Features: ' + this.xrSession.enabledFeatures.join(', '));
        }

        // IMPORTANT: Cr√©er un hit-test source "viewer" comme fallback
        // Cela fonctionne avec le regard (pas besoin de manette)
        try {
          const viewerSpace = await this.xrSession.requestReferenceSpace('viewer');
          this.hitTestSource = await this.xrSession.requestHitTestSource({ space: viewerSpace });
          this.hitTestSourceRequested = true;
          this.log('Hit-test (viewer) OK !');
        } catch (error) {
          this.log('Hit-test error: ' + error.message);
        }

        // √âcouter les √©v√©nements "select" (trigger de la manette ou tap)
        this.xrSession.addEventListener('select', this.onSelect.bind(this));

        // Log des input sources
        const inputSources = this.xrSession.inputSources;
        this.log(`Inputs: ${inputSources.length} d√©tect√©s`);

        this.log('Pr√™t ! Visez et appuyez');
      },

      /**
       * Calcule le vecteur normal d'une surface √† partir de son quaternion
       * La normale est le vecteur Y (0,1,0) transform√© par le quaternion
       * @param {DOMPointReadOnly} q - Quaternion {x, y, z, w}
       * @returns {Object} Normal {x, y, z}
       */
      quaternionToNormal: function (q) {
        // Rotation du vecteur (0, 1, 0) par le quaternion
        // Formule: v' = q * v * q^-1 (optimis√©e pour vecteur unitaire Y)
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

        // Composantes de la normale apr√®s rotation
        const nx = 2 * (qx * qy - qz * qw);
        const ny = 1 - 2 * (qx * qx + qz * qz);
        const nz = 2 * (qy * qz + qx * qw);

        return { x: nx, y: ny, z: nz };
      },

      onSelect: function (event) {
        this.log('>>> TRIGGER ! <<<');

        if (!this.lastHitPose) {
          this.log('Aucune surface d√©tect√©e');
          return;
        }

        // Placer une tasse √† la position d√©tect√©e
        // On passe aussi la normale stock√©e
        this.placeCup(this.lastHitPose, this.lastHitNormal);
      },

      /**
       * V√©rifie si une surface est un SOL ou TABLE (horizontale vers le haut)
       * @param {Object} normal - Le vecteur normal {x, y, z}
       * @returns {boolean} true si la surface est un sol (normale vers le haut)
       */
      isHorizontalSurface: function (normal) {
        if (!normal) return true; // Par d√©faut on consid√®re horizontal

        // SOL/TABLE = normale qui pointe vers le HAUT : Y > 0.7
        // PLAFOND = normale qui pointe vers le BAS : Y < -0.7 ‚Üí tasse tombe !
        // MUR = normale horizontale : |Y| < 0.7 ‚Üí tasse tombe !

        // On ne retourne true QUE si c'est un vrai sol (normale vers le haut)
        return normal.y > 0.7;
      },

      /**
       * Met √† jour la position du sol invisible pour la physique
       * @param {number} floorY - La hauteur Y du sol d√©tect√©
       */
      updatePhysicsFloor: function (floorY) {
        const floorEl = document.querySelector('#physics-floor');
        if (floorEl && floorY !== undefined) {
          // Ne mettre √† jour que si on a trouv√© un sol plus bas
          if (this.lowestFloorY === undefined || floorY < this.lowestFloorY) {
            this.lowestFloorY = floorY;
            floorEl.setAttribute('position', { x: 0, y: floorY, z: 0 });
            console.log('[AR] Sol physique mis √† jour:', floorY.toFixed(2));
          }
        }
      },

      placeCup: function (pose, normal) {
        const position = pose.position;
        const orientation = pose.orientation;

        // V√©rifier si la surface est horizontale
        const isHorizontal = this.isHorizontalSurface(normal);

        // Cr√©er l'entit√© tasse
        const cupEntity = document.createElement('a-entity');
        cupEntity.setAttribute('gltf-model', '#coffee-cup-model');
        cupEntity.setAttribute('scale', `${this.data.cupScale} ${this.data.cupScale} ${this.data.cupScale}`);

        // ID unique pour debug
        cupEntity.setAttribute('id', `cup-${Date.now()}`);

        // ========== GRABBABLE - Permet de saisir avec les mains ==========
        cupEntity.setAttribute('grabbable', '');

        // IMPORTANT: D√©caler le Y vers le haut pour que la base de la tasse
        // soit sur la surface (pas le centre du mod√®le)
        cupEntity.setAttribute('position', {
          x: position.x,
          y: position.y + this.data.cupYOffset,  // ‚Üê D√©calage vers le haut
          z: position.z
        });

        // ========== PHYSIQUE ==========
        // Toutes les tasses ont un dynamic-body pour pouvoir √™tre saisies et l√¢ch√©es
        cupEntity.addEventListener('model-loaded', () => {
          cupEntity.setAttribute('dynamic-body', {
            mass: 0.3,           // 300g
            shape: 'box',        // Forme de collision simplifi√©e
            linearDamping: 0.3,  // R√©sistance de l'air
            angularDamping: 0.3
          });

          // Configurer les rebonds via le mat√©riau physique
          cupEntity.setAttribute('physics-material', {
            restitution: 0.4,    // Rebond mod√©r√© (0-1)
            friction: 0.5        // Friction au sol
          });

          // Si pos√©e sur surface horizontale, figer temporairement
          if (isHorizontal) {
            // Attendre que le body soit cr√©√©
            setTimeout(() => {
              if (cupEntity.body) {
                cupEntity.body.velocity.set(0, 0, 0);
                cupEntity.body.angularVelocity.set(0, 0, 0);
                cupEntity.body.sleep(); // Mettre en veille (pas de simulation)
              }
            }, 100);
          }
        });

        if (isHorizontal) {
          this.log('‚òï Tasse pos√©e (sol/table)');
          // Mettre √† jour le sol invisible √† cette hauteur
          this.updatePhysicsFloor(position.y);
        } else {
          this.log('‚òï Tasse sur mur ‚Üí TOMBE !');
        }

        // Animation d'apparition
        cupEntity.setAttribute('animation', {
          property: 'scale',
          from: '0 0 0',
          to: `${this.data.cupScale} ${this.data.cupScale} ${this.data.cupScale}`,
          dur: 400,
          easing: 'easeOutBack'
        });

        // Ajouter √† la sc√®ne
        this.el.sceneEl.appendChild(cupEntity);
        this.placedCups.push(cupEntity);

        // Limiter le nombre de tasses
        if (this.placedCups.length > this.data.maxCups) {
          const oldCup = this.placedCups.shift();
          if (oldCup.parentNode) {
            oldCup.parentNode.removeChild(oldCup);
          }
        }

        // Mettre √† jour le compteur
        this.updateCount();

        this.log(`Tasse plac√©e ! (${this.placedCups.length})`);
      },

      updateCount: function () {
        if (this.countEl) {
          this.countEl.textContent = `Tasses plac√©es: ${this.placedCups.length}`;
        }
      },

      tick: function (time, delta) {
        if (!this.sessionInitialized || !this.xrSession || !this.xrRefSpace) {
          return;
        }

        const frame = this.el.sceneEl.frame;
        if (!frame) return;

        // Effectuer le hit-test (utilise le viewer/regard)
        if (this.hitTestSource) {
          try {
            const hitTestResults = frame.getHitTestResults(this.hitTestSource);

            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const hitPose = hit.getPose(this.xrRefSpace);

              if (hitPose) {
                // Surface d√©tect√©e !
                this.lastHitPose = hitPose.transform;

                // Extraire la normale de la surface √† partir du quaternion
                // La normale d'une surface est le vecteur "up" (0, 1, 0) transform√©
                const q = hitPose.transform.orientation;
                this.lastHitNormal = this.quaternionToNormal(q);

                this.updateCursor(hitPose.transform, true);

                // Debug occasionnel (toutes les 60 frames)
                this.hitCount = (this.hitCount || 0) + 1;
                if (this.hitCount % 60 === 1) {
                  const pos = hitPose.transform.position;
                  const normal = this.lastHitNormal;
                  const isHoriz = this.isHorizontalSurface(normal) ? '(horizontal)' : '(vertical)';
                  this.log(`Surface: ${pos.y.toFixed(2)}m ${isHoriz}`);
                }
              }
            } else {
              // Pas de surface d√©tect√©e
              this.updateCursor(null, false);

              // Debug occasionnel
              this.noHitCount = (this.noHitCount || 0) + 1;
              if (this.noHitCount % 120 === 1) {
                this.log('Cherche surface...');
              }
            }
          } catch (error) {
            // Erreur silencieuse
            console.warn('Hit-test error:', error);
          }
        } else {
          // Pas encore de hit-test source
          this.waitCount = (this.waitCount || 0) + 1;
          if (this.waitCount % 120 === 1) {
            this.log('Attente hit-test...');
          }
        }
      },

      updateCursor: function (pose, detected) {
        if (!this.cursorEl) return;

        if (detected && pose) {
          // Afficher le curseur √† la position d√©tect√©e
          this.cursorEl.object3D.visible = true;
          this.cursorEl.object3D.position.set(
            pose.position.x,
            pose.position.y,
            pose.position.z
          );
          this.cursorEl.object3D.quaternion.set(
            pose.orientation.x,
            pose.orientation.y,
            pose.orientation.z,
            pose.orientation.w
          );

          // Couleur verte = surface d√©tect√©e
          this.cursorEl.querySelectorAll('a-ring').forEach(ring => {
            ring.setAttribute('color', '#00FF00');
          });

          // Afficher la pr√©visualisation de la tasse
          if (this.previewEl) {
            this.previewEl.object3D.visible = true;
            this.previewEl.object3D.position.set(
              pose.position.x,
              pose.position.y,
              pose.position.z
            );
          }
        } else {
          // Cacher le curseur
          this.cursorEl.object3D.visible = false;
          if (this.previewEl) {
            this.previewEl.object3D.visible = false;
          }
          this.lastHitPose = null;
        }
      },

      remove: function () {
        // Nettoyer les tasses
        this.placedCups.forEach(cup => {
          if (cup.parentNode) {
            cup.parentNode.removeChild(cup);
          }
        });
        this.placedCups = [];
      }
    });

    /**
     * =================================================================
     * Composant : ar-plane-detector
     * Description : D√©tecte les surfaces r√©elles (sol, murs, tables)
     * et cr√©e des colliders invisibles pour la physique
     * =================================================================
     */
    AFRAME.registerComponent('ar-plane-detector', {
      schema: {
        showPlanes: { type: 'boolean', default: false },  // Afficher les plans en debug
        horizontalColor: { type: 'color', default: '#00FF00' },  // Couleur sol/tables
        verticalColor: { type: 'color', default: '#0088FF' }     // Couleur murs
      },

      init: function () {
        this.detectedPlanes = new Map();  // Map<XRPlane, A-Frame Entity>
        this.planeEntities = [];
        this.xrSession = null;
        this.xrRefSpace = null;
        this.initialized = false;
        this.planeCount = { horizontal: 0, vertical: 0 };
        this.frameCount = 0;
        this.debugTextEl = document.querySelector('#vr-debug-text');

        // √âcouter les √©v√©nements de session
        this.el.sceneEl.addEventListener('enter-vr', this.onEnterVR.bind(this));
        this.el.sceneEl.addEventListener('exit-vr', this.onExitVR.bind(this));

        console.log('[Plane Detector] Initialis√© (showPlanes:', this.data.showPlanes, ')');
      },

      log: function (message) {
        console.log('[Plane Detector]', message);
        // Mettre √† jour le debug VR
        if (this.debugTextEl) {
          this.debugTextEl.setAttribute('value', 'Planes: ' + message);
        }
      },

      onEnterVR: function () {
        console.log('[Plane Detector] Entr√©e VR/AR');

        setTimeout(() => {
          this.xrSession = this.el.sceneEl.renderer.xr.getSession();
          this.xrRefSpace = this.el.sceneEl.renderer.xr.getReferenceSpace();

          if (this.xrSession) {
            this.initialized = true;
            console.log('[Plane Detector] Session OK');

            // V√©rifier si plane-detection est disponible
            if (this.xrSession.enabledFeatures) {
              const hasPlaneDetection = this.xrSession.enabledFeatures.includes('plane-detection');
              console.log('[Plane Detector] plane-detection disponible:', hasPlaneDetection);
            }
          }
        }, 1000);
      },

      onExitVR: function () {
        console.log('[Plane Detector] Sortie VR/AR');
        this.cleanup();
      },

      tick: function (time, delta) {
        if (!this.initialized || !this.xrSession || !this.xrRefSpace) {
          return;
        }

        const frame = this.el.sceneEl.frame;
        if (!frame) return;

        this.frameCount++;

        // V√©rifier si detectedPlanes existe sur le frame
        if (!frame.detectedPlanes) {
          // plane-detection pas support√© ou pas activ√©
          if (this.frameCount === 60) {
            this.log('Pas de planes (60 frames)');
            console.warn('[Plane Detector] frame.detectedPlanes non disponible. V√©rifiez que:');
            console.warn('  1. plane-detection est dans les features');
            console.warn('  2. Le Room Setup Quest est configur√©');
            console.warn('  3. L\'appareil supporte plane-detection');
          }
          return;
        }

        // Log occasionnel
        if (this.frameCount % 120 === 1 && frame.detectedPlanes.size > 0) {
          this.log(`${frame.detectedPlanes.size} plans actifs`);
        }

        // Parcourir tous les plans d√©tect√©s
        frame.detectedPlanes.forEach((plane) => {
          // V√©rifier si on a d√©j√† cr√©√© une entit√© pour ce plan
          if (!this.detectedPlanes.has(plane)) {
            // Nouveau plan d√©tect√© !
            this.createPlaneEntity(plane, frame);
          } else {
            // Mettre √† jour la position du plan existant
            this.updatePlaneEntity(plane, frame);
          }
        });

        // Supprimer les plans qui ne sont plus d√©tect√©s
        this.detectedPlanes.forEach((entity, plane) => {
          if (!frame.detectedPlanes.has(plane)) {
            this.removePlaneEntity(plane);
          }
        });
      },

      createPlaneEntity: function (plane, frame) {
        try {
          const pose = frame.getPose(plane.planeSpace, this.xrRefSpace);
          if (!pose) return;

          const position = pose.transform.position;
          const orientation = pose.transform.orientation;

          // Calculer les dimensions du plan √† partir du polygon
          const dimensions = this.calculatePlaneDimensions(plane.polygon);
          if (!dimensions) return;

          // Cr√©er l'entit√© A-Frame
          const planeEntity = document.createElement('a-box');

          // Configuration de base
          planeEntity.setAttribute('position', {
            x: position.x,
            y: position.y,
            z: position.z
          });

          // Quaternion pour l'orientation
          planeEntity.object3D.quaternion.set(
            orientation.x,
            orientation.y,
            orientation.z,
            orientation.w
          );

          // Dimensions (tr√®s fin en Y pour les plans horizontaux)
          if (plane.orientation === 'horizontal') {
            planeEntity.setAttribute('scale', {
              x: dimensions.width,
              y: 0.01,  // Tr√®s fin
              z: dimensions.height
            });
            this.planeCount.horizontal++;
          } else {
            planeEntity.setAttribute('scale', {
              x: dimensions.width,
              y: dimensions.height,
              z: 0.01  // Tr√®s fin
            });
            this.planeCount.vertical++;
          }

          // Apparence
          if (this.data.showPlanes) {
            const color = plane.orientation === 'horizontal'
              ? this.data.horizontalColor
              : this.data.verticalColor;

            planeEntity.setAttribute('material', {
              color: color,
              opacity: 0.3,
              transparent: true,
              shader: 'flat'
            });
          } else {
            planeEntity.setAttribute('visible', false);
          }

          // Ajouter une classe pour identification
          planeEntity.classList.add('detected-plane');
          planeEntity.classList.add(plane.orientation === 'horizontal' ? 'plane-horizontal' : 'plane-vertical');

          // Stocker des infos sur le plan
          planeEntity.dataset.planeOrientation = plane.orientation;

          // Ajouter √† la sc√®ne
          this.el.sceneEl.appendChild(planeEntity);

          // Enregistrer dans notre Map
          this.detectedPlanes.set(plane, planeEntity);
          this.planeEntities.push(planeEntity);

          console.log(`[Plane Detector] Nouveau plan ${plane.orientation}: ${dimensions.width.toFixed(2)}x${dimensions.height.toFixed(2)}m`);
          console.log(`[Plane Detector] Total: ${this.planeCount.horizontal} horizontal, ${this.planeCount.vertical} vertical`);

        } catch (error) {
          console.warn('[Plane Detector] Erreur cr√©ation plan:', error);
        }
      },

      updatePlaneEntity: function (plane, frame) {
        const entity = this.detectedPlanes.get(plane);
        if (!entity) return;

        try {
          const pose = frame.getPose(plane.planeSpace, this.xrRefSpace);
          if (!pose) return;

          // Mettre √† jour la position
          entity.object3D.position.set(
            pose.transform.position.x,
            pose.transform.position.y,
            pose.transform.position.z
          );

          // Mettre √† jour l'orientation
          entity.object3D.quaternion.set(
            pose.transform.orientation.x,
            pose.transform.orientation.y,
            pose.transform.orientation.z,
            pose.transform.orientation.w
          );

        } catch (error) {
          // Silencieux
        }
      },

      removePlaneEntity: function (plane) {
        const entity = this.detectedPlanes.get(plane);
        if (entity) {
          if (entity.parentNode) {
            entity.parentNode.removeChild(entity);
          }

          // Mettre √† jour le compteur
          if (entity.dataset.planeOrientation === 'horizontal') {
            this.planeCount.horizontal--;
          } else {
            this.planeCount.vertical--;
          }

          // Retirer de nos listes
          this.detectedPlanes.delete(plane);
          const idx = this.planeEntities.indexOf(entity);
          if (idx > -1) {
            this.planeEntities.splice(idx, 1);
          }

          console.log('[Plane Detector] Plan supprim√©');
        }
      },

      calculatePlaneDimensions: function (polygon) {
        if (!polygon || polygon.length < 3) {
          return { width: 0.5, height: 0.5 };  // Valeur par d√©faut
        }

        // Trouver les min/max pour calculer la bounding box
        let minX = Infinity, maxX = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;

        for (const point of polygon) {
          minX = Math.min(minX, point.x);
          maxX = Math.max(maxX, point.x);
          minZ = Math.min(minZ, point.z);
          maxZ = Math.max(maxZ, point.z);
        }

        return {
          width: Math.max(maxX - minX, 0.1),
          height: Math.max(maxZ - minZ, 0.1)
        };
      },

      cleanup: function () {
        // Supprimer toutes les entit√©s de plan
        this.planeEntities.forEach(entity => {
          if (entity.parentNode) {
            entity.parentNode.removeChild(entity);
          }
        });

        this.detectedPlanes.clear();
        this.planeEntities = [];
        this.planeCount = { horizontal: 0, vertical: 0 };
        this.initialized = false;

        console.log('[Plane Detector] Nettoyage effectu√©');
      },

      remove: function () {
        this.cleanup();
      },

      // M√©thode publique pour r√©cup√©rer les plans (utile pour la physique)
      getPlanes: function () {
        return {
          all: this.planeEntities,
          horizontal: this.planeEntities.filter(e => e.dataset.planeOrientation === 'horizontal'),
          vertical: this.planeEntities.filter(e => e.dataset.planeOrientation === 'vertical')
        };
      }
    });
  </script>
</body>

</html>