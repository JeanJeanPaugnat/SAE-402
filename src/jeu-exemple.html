<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>AR Anchors - Quest 3</title>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        z-index: 1000;
        max-width: 300px;
      }
      #info h2 { margin: 0 0 10px 0; font-size: 18px; }
      #info p { margin: 5px 0; font-size: 14px; }
    </style>
  </head>
  <body>
    <div id="info">
      <h2>üåª AR Anchors (Quest 3)</h2>
      <p>Entrez en mode VR et tapez pour placer des tournesols</p>
      <p id="count">Tournesols: 0</p>
      <p id="debug" style="font-size: 12px; color: #FFD700; margin-top: 10px;">Debug: Ready</p>
    </div>

    <a-scene 
      webxr="requiredFeatures: anchors, local-floor; optionalFeatures: hit-test;"
      vr-mode-ui="enabled: false"
      ar-button
      ar-anchors-quest3>
      
      <a-assets>
        <a-asset-item id="sunflower" src="media/gltf/sunflower/sunflower.gltf"></a-asset-item>
      </a-assets>
      
      <a-camera position="0 1.6 0">
        <!-- Reticle au centre de la vue -->
        <a-ring position="0 0 -1.5" radius-inner="0.02" radius-outer="0.03" color="#00FF00" id="reticle"></a-ring>
        
        <!-- Panneau de d√©bogage visible dans le casque -->
        <a-text id="debug-text" value="Debug: Ready" position="0 0.3 -1" scale="0.5 0.5 0.5" color="#00FF00" align="center"></a-text>
      </a-camera>
      
      <!-- Curseur/pointeur qui suivra le hit-test -->
      <a-entity id="cursor" visible="true">
        <a-ring color="#00FF00" radius-inner="0.08" radius-outer="0.12" rotation="-90 0 0"></a-ring>
        <a-ring color="#FFFF00" radius-inner="0.04" radius-outer="0.06" rotation="-90 0 0"></a-ring>
        <a-cone color="#00FF00" height="0.15" radius-bottom="0.04" radius-top="0" position="0 0.08 0"></a-cone>
      </a-entity>
      
      <a-light type="ambient" intensity="0.6"></a-light>
      <a-light type="directional" position="1 2 1" intensity="0.8"></a-light>
    </a-scene>

    <script>
      // Bouton pour d√©marrer en mode AR
      AFRAME.registerComponent('ar-button', {
        init: function() {
          const button = document.createElement('button');
          button.textContent = 'START AR';
          button.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 9999;
          `;
          
          button.onclick = async () => {
            const sceneEl = this.el.sceneEl;
            
            // Demander une session AR avec hit-test
            try {
              const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local-floor', 'hit-test'],
                optionalFeatures: ['anchors']
              });
              
              sceneEl.renderer.xr.setSession(session);
              button.style.display = 'none';
              console.log('AR session started with hit-test');
            } catch (error) {
              console.error('Failed to start AR session:', error);
              alert('Erreur: ' + error.message);
            }
          };
          
          document.body.appendChild(button);
        }
      });

      AFRAME.registerComponent('ar-anchors-quest3', {
        schema: {
          maxAnchors: {type: 'number', default: 20}
        },

        init: function() {
          this.anchors = [];
          this.sceneEl = this.el.sceneEl;
          this.xrSession = null;
          this.xrRefSpace = null;
          this.hitTestSource = null;
          this.hitTestSourceRequested = false;
          this.cursorEl = document.querySelector('#cursor');
          this.lastHitPose = null;
          this.debugTextEl = null;
          this.debugLog = [];
          this.sessionInitialized = false;
          this.hitCount = 0;
          this.noHitCount = 0;
          this.rightControllerSpace = null;
          this.lastValidHitPose = null;
          this.framesSinceLastHit = 0;
          this.smoothedPosition = new THREE.Vector3();
          this.smoothedQuaternion = new THREE.Quaternion();
          
          this.sceneEl.addEventListener('enter-vr', this.onEnterVR.bind(this));
          this.sceneEl.addEventListener('exit-vr', this.onExitVR.bind(this));
          
          this.log('Component initialized');
        },

        log: function(message) {
          console.log(message);
          this.debugLog.push(message);
          if (this.debugLog.length > 5) this.debugLog.shift();
          
          const debugText = this.debugLog.join('\n');
          
          // Update HTML debug
          const debugEl = document.querySelector('#debug');
          if (debugEl) debugEl.textContent = message;
          
          // Update VR debug text
          setTimeout(() => {
            this.debugTextEl = document.querySelector('#debug-text');
            if (this.debugTextEl) {
              this.debugTextEl.setAttribute('value', debugText);
            }
          }, 100);
        },

        onEnterVR: async function() {
          this.log('Entered VR mode');
          
          // Attendre un peu pour que la session soit bien √©tablie
          setTimeout(async () => {
            this.xrSession = this.sceneEl.renderer.xr.getSession();
            this.xrRefSpace = this.sceneEl.renderer.xr.getReferenceSpace();
            
            if (this.xrSession) {
              this.log('XR Session OK');
              
              // Initialiser le hit-testing
              try {
                const viewerSpace = await this.xrSession.requestReferenceSpace('viewer');
                this.hitTestSource = await this.xrSession.requestHitTestSource({ space: viewerSpace });
                this.log('Hit test OK');
              } catch (error) {
                this.log('Hit test FAIL: ' + error.message);
              }
              
              // √âcouter les √©v√©nements select (trigger/tap)
              this.xrSession.addEventListener('select', this.onSelect.bind(this));
              this.log('Listeners OK - Press trigger!');
              
              // Afficher des instructions
              const statusEl = document.querySelector('#status');
              if (statusEl) {
                statusEl.textContent = 'Visez une surface et appuyez sur le trigger pour placer un tournesol';
              }
            } else {
              this.log('XR Session FAIL');
            }
          }, 500);
        },

        onExitVR: function() {
          console.log('Exited VR mode');
          if (this.xrSession) {
            this.xrSession.removeEventListener('select', this.onSelect.bind(this));
          }
          if (this.hitTestSource) {
            this.hitTestSource.cancel();
            this.hitTestSource = null;
          }
          this.cleanupAnchors();
        },

        onSelect: function(event) {
          this.log('>>> TRIGGER PRESSED! <<<');
          
          if (!this.xrSession || !this.xrRefSpace) {
            this.log('Session not ready');
            return;
          }

          // PRIORITE: Utiliser la pose du hit test de la manette si disponible
          if (this.lastHitPose) {
            this.log('Placing on pointed surface');
            this.createAnchorAtPose(this.lastHitPose);
            return;
          }

          // Sinon, placer o√π pointe la manette
          const frame = event.frame;
          const inputSource = event.inputSource;
          
          if (!frame || !inputSource) {
            this.log('No frame or input');
            return;
          }

          this.log('Placing at controller ray');
          
          // Utiliser le ray du contr√¥leur
          const inputPose = frame.getPose(inputSource.targetRaySpace, this.xrRefSpace);
          if (inputPose) {
            // Placer √† 1.5m le long du ray
            const pos = inputPose.transform.position;
            const orient = inputPose.transform.orientation;
            
            const quat = new THREE.Quaternion(orient.x, orient.y, orient.z, orient.w);
            const direction = new THREE.Vector3(0, 0, -1.5);
            direction.applyQuaternion(quat);
            
            const targetPos = {
              x: pos.x + direction.x,
              y: pos.y + direction.y,
              z: pos.z + direction.z
            };
            
            const anchorPose = new XRRigidTransform(targetPos);
            this.createAnchorAtPose(anchorPose);
          } else {
            this.log('No controller pose');
          }
        },

        createAnchorAtPose: function(pose) {
          this.log('Creating anchor...');
          
          // Cr√©er l'anchor
          this.xrSession.requestAnimationFrame((time, frame) => {
            if (frame.createAnchor) {
              frame.createAnchor(pose, this.xrRefSpace)
                .then((anchor) => {
                  this.log('Anchor created! Total: ' + (this.anchors.length + 1));
                  this.addSunflower(anchor);
                })
                .catch((error) => {
                  this.log('Anchor FAILED: ' + error.message);
                });
            } else {
              this.log('createAnchor not supported!');
            }
          });
        },

        addSunflower: function(anchor) {
          const entity = document.createElement('a-entity');
          entity.setAttribute('gltf-model', '#sunflower');
          entity.setAttribute('scale', '1 1 1');
          
          // Animation d'apparition
          entity.setAttribute('animation', {
            property: 'scale',
            from: '0 0 0',
            to: '1 1 1',
            dur: 400,
            easing: 'easeOutBack'
          });
          
          entity.anchor = anchor;
          this.sceneEl.appendChild(entity);
          this.anchors.push(entity);
          
          // Limiter le nombre
          if (this.anchors.length > this.data.maxAnchors) {
            const old = this.anchors.shift();
            if (old.anchor) old.anchor.delete();
            if (old.parentNode) old.parentNode.removeChild(old);
          }
          
          this.updateCount();
          console.log(`Total anchors: ${this.anchors.length}`);
        },

        updateCount: function() {
          const el = document.querySelector('#count');
          if (el) el.textContent = `Tournesols: ${this.anchors.length}`;
        },

        cleanupAnchors: function() {
          this.anchors.forEach(entity => {
            if (entity.anchor) entity.anchor.delete();
            if (entity.parentNode) entity.parentNode.removeChild(entity);
          });
          this.anchors = [];
          this.updateCount();
        },

        tick: function(time, delta) {
          // V√©rifier si une session XR est active et pas encore initialis√©e
          if (!this.sessionInitialized) {
            const session = this.sceneEl.renderer.xr.getSession();
            if (session) {
              this.log('Session detected in tick!');
              this.initializeSession();
              return;
            }
          }
          
          if (!this.xrSession || !this.xrRefSpace) return;
          
          const frame = this.sceneEl.frame;
          if (!frame) return;
          
          // Obtenir les input sources (manettes)
          const inputSources = this.xrSession.inputSources;
          let rightController = null;
          
          // Trouver la manette droite
          for (let i = 0; i < inputSources.length; i++) {
            const inputSource = inputSources[i];
            if (inputSource.handedness === 'right') {
              rightController = inputSource;
              
              // Cr√©er un hit test source pour ce contr√¥leur si pas d√©j√† fait
              if (!this.hitTestSourceRequested && rightController.targetRaySpace) {
                this.hitTestSourceRequested = true;
                this.log('Creating HT source...');
                this.xrSession.requestHitTestSource({ space: rightController.targetRaySpace })
                  .then((source) => {
                    this.hitTestSource = source;
                    this.log('HT source created!');
                  })
                  .catch((error) => {
                    this.log('HT error: ' + error.message);
                  });
              }
              break;
            }
          }
          
          let surfaceDetected = false;
          
          // Essayer le hit-testing standard
          if (this.hitTestSource) {
            try {
              const hitTestResults = frame.getHitTestResults(this.hitTestSource);
              
              if (hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                const hitPose = hit.getPose(this.xrRefSpace);
                
                if (hitPose) {
                  // V√©rifier que la position d√©tect√©e est √† une distance raisonnable du contr√¥leur
                  const controllerPos = frame.getPose(rightController.targetRaySpace, this.xrRefSpace);
                  if (controllerPos) {
                    const dx = hitPose.transform.position.x - controllerPos.transform.position.x;
                    const dy = hitPose.transform.position.y - controllerPos.transform.position.y;
                    const dz = hitPose.transform.position.z - controllerPos.transform.position.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    // Accepter seulement si la distance est > 0.5m (pour √©viter les d√©tections sur la main)
                    if (distance > 0.5) {
                      surfaceDetected = true;
                      this.hitCount++;
                      this.framesSinceLastHit = 0;
                      this.lastValidHitPose = hitPose.transform;
                      
                      if (this.hitCount % 30 === 0) {
                        this.log('HIT! ' + this.hitCount);
                      }
                      
                      this.lastHitPose = hitPose.transform;
                      
                      // Positionner le curseur directement sans lissage
                      if (this.cursorEl) {
                        this.cursorEl.object3D.position.set(
                          hitPose.transform.position.x,
                          hitPose.transform.position.y,
                          hitPose.transform.position.z
                        );
                        this.cursorEl.object3D.quaternion.set(
                          hitPose.transform.orientation.x,
                          hitPose.transform.orientation.y,
                          hitPose.transform.orientation.z,
                          hitPose.transform.orientation.w
                        );
                        this.cursorEl.object3D.visible = true;
                        
                        // Changer la couleur pour indiquer la d√©tection
                        const rings = this.cursorEl.querySelectorAll('a-ring');
                        rings.forEach(ring => ring.setAttribute('color', '#00FF00'));
                      }
                    }
                  }
                }
              } else {
                this.noHitCount++;
                this.framesSinceLastHit++;
                
                // Ne garder la position que bri√®vement (10 frames)
                if (this.lastValidHitPose && this.framesSinceLastHit < 10) {
                  surfaceDetected = true;
                  this.lastHitPose = this.lastValidHitPose;
                  
                  if (this.cursorEl) {
                    // Curseur jaune pour indiquer l'estimation
                    const rings = this.cursorEl.querySelectorAll('a-ring');
                    rings.forEach(ring => ring.setAttribute('color', '#FFFF00'));
                  }
                }
                
                if (this.noHitCount === 60) {
                  this.log('No surface. Move around!');
                }
              }
            } catch (error) {
              // Erreur silencieuse
            }
          }
          
          // Si pas de surface d√©tect√©e, positionner le curseur le long du ray
          if (!surfaceDetected && rightController && rightController.targetRaySpace) {
            const controllerPose = frame.getPose(rightController.targetRaySpace, this.xrRefSpace);
            
            if (controllerPose) {
              const pos = controllerPose.transform.position;
              const orient = controllerPose.transform.orientation;
              
              // Calculer la position √† 2m le long du ray (distance augment√©e)
              const quat = new THREE.Quaternion(orient.x, orient.y, orient.z, orient.w);
              const direction = new THREE.Vector3(0, 0, -2.0); // Distance augment√©e
              direction.applyQuaternion(quat);
              
              const targetPos = {
                x: pos.x + direction.x,
                y: pos.y + direction.y,
                z: pos.z + direction.z
              };
              
              // V√©rifier que le curseur est assez loin du contr√¥leur
              const distance = Math.sqrt(
                direction.x * direction.x +
                direction.y * direction.y +
                direction.z * direction.z
              );
              
              // Seulement afficher si la distance est raisonnable
              if (distance > 1.0) {
                // Cr√©er une orientation qui fait face "vers le haut" par rapport au ray
                const rayDirection = new THREE.Vector3(0, 0, -1);
                rayDirection.applyQuaternion(quat);
                rayDirection.normalize();
                
                const up = new THREE.Vector3(0, 1, 0);
                const cursorQuat = new THREE.Quaternion();
                
                const lookAt = new THREE.Matrix4();
                lookAt.lookAt(
                  new THREE.Vector3(0, 0, 0),
                  rayDirection.multiplyScalar(-1),
                  up
                );
                cursorQuat.setFromRotationMatrix(lookAt);
                
                // Sauvegarder cette pose pour le placement
                this.lastHitPose = new XRRigidTransform(targetPos, {
                  x: cursorQuat.x,
                  y: cursorQuat.y,
                  z: cursorQuat.z,
                  w: cursorQuat.w
                });
                
                // Positionner le curseur
                if (this.cursorEl) {
                  this.cursorEl.object3D.position.set(targetPos.x, targetPos.y, targetPos.z);
                  this.cursorEl.object3D.quaternion.copy(cursorQuat);
                  this.cursorEl.object3D.visible = true;
                  
                  // Changer la couleur pour indiquer pas de surface d√©tect√©e
                  const rings = this.cursorEl.querySelectorAll('a-ring');
                  rings.forEach((ring, idx) => {
                    ring.setAttribute('color', idx === 0 ? '#FFFF00' : '#FF8800');
                  });
                }
              }
            }
          } else if (!surfaceDetected && !rightController) {
            // Pas de manette d√©tect√©e, cacher le curseur
            if (this.cursorEl) {
              this.cursorEl.object3D.visible = false;
            }
            this.lastHitPose = null;
          }
          
          // Mettre √† jour la position de chaque tournesol
          this.anchors.forEach((entity) => {
            if (!entity.anchor) return;
            
            try {
              const pose = frame.getPose(entity.anchor.anchorSpace, this.xrRefSpace);
              
              if (pose) {
                const pos = pose.transform.position;
                const rot = pose.transform.orientation;
                
                entity.object3D.position.set(pos.x, pos.y, pos.z);
                entity.object3D.quaternion.set(rot.x, rot.y, rot.z, rot.w);
                entity.object3D.visible = true;
              } else {
                entity.object3D.visible = false;
              }
            } catch (e) {
              // Silently handle errors
            }
          });
        },

        initializeSession: async function() {
          this.sessionInitialized = true;
          this.log('Initializing session...');
          
          this.xrSession = this.sceneEl.renderer.xr.getSession();
          this.xrRefSpace = this.sceneEl.renderer.xr.getReferenceSpace();
          
          if (this.xrSession) {
            this.log('XR Session OK');
            
            // V√©rifier les features disponibles
            if (this.xrSession.enabledFeatures) {
              this.log('Features: ' + this.xrSession.enabledFeatures.join(', '));
            }
            
            // Le hit-test source sera cr√©√© dynamiquement dans tick quand on d√©tecte le contr√¥leur
            
            // √âcouter les √©v√©nements select (trigger/tap)
            this.xrSession.addEventListener('select', this.onSelect.bind(this));
            this.log('Ready! Scan surfaces');
          } else {
            this.log('XR Session FAIL');
            this.sessionInitialized = false;
          }
        },

        remove: function() {
          this.cleanupAnchors();
        }
      });
    </script>
  </body>
</html>
